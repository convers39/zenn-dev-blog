---
title: "コーディングテストでグラフ問題にチャレンジした話"
emoji: "💦"
type: "tech"
topics:
  - "algorithm"
  - "graph"
  - "interview"
published: false
published_at: "2022-07-02 15:19"
---

今回はアゴリズムの話です。

最近転職活動していて、とある会社さんからのコーディングテストの問題です。

```
有向図のノードxからノードxへ戻る最短パスを求めてください
```

はい、これだけです。

### コーディングテストの心得

これは、問題を解く前のメタ的な考え方です。

- 問題ははっきりとなってない場合もあるので、面接官との確認と議論が必須
- 行きなりコードを書くのではなく、問題の分析から始める
- 可能な選択肢をできる範囲内で示し、時間と空間の複雑度分析も行う
- データ構造とアゴリズムだけではクリア不可な場合が多く、むしろ自分の考え方を説明・議論しながら、面接官とのコミュニケーションが重視される（すでに答えがわかっても黙々と書くのはアウト）
- 時間的にバランスをとった方が良い、例えば50分があるとしたら、20-25分程度で問題の分析、文章化にした方が良い
- ホワイトボード（オンラインの場合はGoogleドック）の可能性も十分あるので練習時はIDEとかを使わない

以上を踏まえて、今回のコーディングテストの問題を見ていきたいと思います。

### 問題の条件を確認

正直この問題を見た瞬間、「ヤベェー」と心の声が叫んでいました。

というのは、今までグラフ系の問題全く解いたことがなく、面接時にこれとあったらほぼ終わりじゃん、という先入観がありました。

ただただ、このままでは終わらんぞ。グラフ系はないけど、木の問題は割とやっていましたので、pre-order, in-order, post-orderのトラバース、DFS(深さ優先探索)も多少理解はあります。BFS(幅優先探索)は確かまた書いたことないですが、考え方は一応理解しているつもりです。ここは一旦落ち着いて、自分の持っている知識で戦うしかないと。

この問題の文面はかなり短いので、パッと見て「ん？」となってしまうかもしれません。なので何をやって欲しいのかをまずしっかりと確認した方がよさそう。

- 有向図(digraph/directed graph)：この概念は結構大事で、それに対して無向図(undirected graph)があります。「要するにノードの間に一方通行の→がついていることですよね」と聞いて、面接官からは肯定的な回答。
- ノードxからノードxへ戻る：つまりサイクルがあって、同じノードに戻れること。ここでもう一つ確認したのは、ノードxへ戻ることは保証されているかどうか、もしくは戻れないケースもあるかどうか。面接官からの答えは「戻れないケースもある」。
- 最短パス：最短というのはどういうふうに表すのか、リターン値はノードの配列を入れれば良いかを確認。答えは「ノードかエッジの配列で良い」。

Googleドックで書いているので、以上を確認しながらノートも書きました。それで問題は以下となります：

```
有向図のノードxからノードxへ戻る最短パスを求めてください

- ノードから隣接するノードへ一方通行でトラバース
- リターン値はノードかエッジの配列（エッジの表現が思いついていないのでノードだけを考える）
- ノードxへ戻れる場合と戻れない場合は存在
  - 存在する場合は、ノードxからノードxまでのノードをパス配列として記録しリターン
  - 存在しない場合は、空の配列をリターン
```

### 木とグラフの違い

何をやってほしいのかは大体分かりましたので、その後は解決案の分析です。に入る前に少し前提知識を。

いろんなデータ構造、配列、連結リスト、木、ハッシュテーブル、ハッシュセット、グラフなどありますが、根本的にメモリでの保存形式から見ると2種類しかありません。

- 連続したメモリーを使うタイプ
- 連続しないメモリーを使うタイプ

前者は配列、ハッシュテーブル、ハッシュセットが代表的。連続しているメモリー空間を使っているので、インデックスを利用してO(1)の時間複雑度でランダムアクセスが可能。後者は連結リスト、木、グラフなどが代表的。連続しているメモリー空間を使っていなく、代わりに次のアドレスを保存するポインターが存在する。ただこれで配列のようにO(1)のランダムアクセスがもちろんできない。

これを分かった上で、木とグラフはどちらかというとかなり近いデータ構造になります。一番大きな区別というと、木にはサイクルが存在しないが、グラフにはサイクルが存在するところです。

![](https://storage.googleapis.com/zenn-user-upload/31ded6e089fc-20220702.png)

この違いにより、グラフをトラバースするときに一つ問題が生じます。訪問済みのノードに戻ってしまい、無限ループになる問題があるところです。この問題を解決するには、通常ハッシュセットを導入して、訪問済みのノードを記録することです。

自分にはグラフについての経験と知識があまりないのですが、木及び木とグラフの関連と違いについては分かっているので、面接時はまずここから説明していました。というのも、もし最終的に解けなかったとしても、基礎の知識と考え方を説明した方がプラスになると思うからです。

### トラバース方法の選択

#### 木から考える

二分木のトラバースには、pre-order, in-order, post-orderの方法があります。それぞれ、ノードに入ったとき、ノードの左枝が終わって右枝に入る前、ノードの左枝と右枝が終わってノードから離れるとき、のタイミングと対応しています。N分木にはin-orderがないため（枝が2つ以上あるため）、汎用性で言えば、pre-orderとpost-orderが用いられます。

post-orderの方は、左枝を優先に探索し、次に右枝、最後はノード自身となるので、DFSの実例でもあります。DFSは空間複雑度（メモリー使用）が少ないのですが、再帰の形でスタックに積んで行きます。テンプレート的な考え方をjsコードで表現すると以下となります。再帰についてあまり理解していないとここは苦しむかもしれませんが、原則として、**現時点のノードにおいて何をするかだけを考える**のです。

```js
// 二分木
class Node {
  constructor(val = 0, left = null, right = null) {
    this.val = val
    this.left = left
    this.right = right
  }
}
function dfs(node) {
  if (node === null) return
  // preorder　この時点でまだ枝のトラバースが始まっていなく、node自身にある
  //-----
  dfs(node.left)
  //-----
  // inorder　この時点で左が終わったが右はまだ、今はnode自身にある
  //-----
  dfs(node.right)
  //-----
  // postorder　この時点で右と左の枝のトラバースが終わったため、その結果を持って何かの操作が可能
}

// N分木
class Node {
  constructor(val = 0, children = []) {
    this.val = val
    this.children = children
  }
}
function dfs(node) {
  if (node === null) return
  // preorder　この時点でまだ枝のトラバースが始まっていなく、node自身にある
  //-----
  for (const child of node.children) {
    dfs(child)
  }
  //-----
  // postorder　この時点で子供ノードのトラバースが終わったため、その結果を持って何かの操作が可能
}
```

DFSの深さ優先に対して、BFSの幅優先探索方法もありますが、再帰を利用しておらず、多少理解しやすいかもしれません。考え方としては、任意のノードにおいて、そのノードの子供ノード（グラフの場合は隣接ノード）を一つのキューに入れて、キューが空になるまで処理を続けること。


```js
function bfs(root) {
  let queue = [root] // 配列でキューを実装
  let depth = 0 // bfsが同じ階層のものを一度全部訪問するので、ここは階層を記録
  while (queue.length > 0) { // キューにノードがある限り処理を続ける
    const n = queue.length 
    // 現在のキューにあるノードに対してループ、ただもしdepthに関心がない場合これは不要
    for (let i = 0; i < n; i++) { 
      const node = queue.shift() // キューの先頭からノードを取り出す
      for (const child of node.children) { // ノードの隣接ノードをループ
        // ここで何か処理を行う、例えばターゲットノードであればリターン
        if (isTarget(child)) return child
        queue.push(child) // ノードをキューにプッシュ
      }
    }
    // ここで階層を1つ増やす
    depth++;
  }
}
```

#### グラフまで拡張

これをグラフに応用すると、右と左の枝とは限らず、一般的に任意のノードに対して、**隣接ノード**を配列の形で保存すると考えても良いかと。先ほども触れましたが、グラフにサイクルの存在があり得るため、訪問済みをマークするためにハッシュセットが必要。それ以外にほぼ同じように見えますね。

```js
class Node {
  constructor(val = 0, neighbors = []) {
    this.val = val
    this.neighbors = neighbors
  }
}
// let visited = new Set()

function dfs(root, visited) {
  if (!root) return
  for (const neighbor of root.neighbors) { // ノードの隣接ノードをループ
    if (visited.has(neighbor)) continue // 訪問済みの場合はスキップ
    visited.add(neighbor) // 訪問していない場合はハッシュセットに追加
    dfs(neighbor, visited) // ループ中のノードに対して再帰呼び出し
  }
}
```

それでbfsの考え方も下記の通りで拡張すれば良いでしょう。

```js
function bfs(root) {
  let queue = [root] // 配列でキューを実装
  let visited = new Set([root]) // ハッシュセットで訪問済みのノードを追加
  let depth = 0 // bfsが同じ階層のものを一度全部訪問するので、ここは階層を記録
  while (queue.length > 0) { // キューにノードがある限り処理を続ける
    const n = queue.length 
    // 現在のキューにあるノードに対してループ、ただもしdepthに関心がない場合これは不要
    for (let i = 0; i < n; i++) { 
      const node = queue.shift() // キューの先頭からノードを取り出す
      for (const neighbor of node.neighbors) { // ノードの隣接ノードをループ
        if (visited.has(neighbor)) continue // 訪問済みのノードはスキップ
        // この辺りで何か処理を行う
        queue.push(neighbor) // 訪問していないノードをキューにプッシュ
        visited.add(neighbor) // 同時に訪問済みとマーク
      }
    }
    // ここで階層を1つ増やす
    depth++;
  }
}
```

もちろん、こんなテンプレート的なコードを暗記しているわけではありません。考え方だけ覚えているので、これが非常に助けになっています。アゴリズムはコードを覚えても意味がほぼなく、考え方もしくはメンタルモデルの構築が肝心だと思います。

この時点でbfsとdfs、どちらにするかとの選択になります。一般的に言えば：

- bfsは階層毎に進めるので、ノードの間の距離は常に最短（エッジ自体がunweightedの場合）、ただキューとかハッシュセットとかがあるためメモリ使用量がdfsより高い。
- dfsは効率的に遠くにあるノードを見つけることができる、つまり深さと関わる問題に適している。最短も求められますが、全ての回答を見つけてその中からまた最短を絞り出すことになり、効率がbfsより良くない

dfsはスタック＋再帰、bfsはキュー＋whileループというイメージです。[表](https://iq.opengenus.org/dfs-vs-bfs/)にまとめると：

| 項目           | DFS          | BFS            |
| -------------- | ------------ | -------------- |
| トラバース順番 | 深さ・Depth  | 幅・Level      |
| データ構造     | スタック     | キュー         |
| 時間複雑度     | O(V + E)     | O(V + E)       |
| 空間複雑度     | O(V)         | O(V)           |
| ルート特徴     | 狭いかつ長い | 幅広いかつ短い |

*V = vertex/頂点、ノードと同じ意味の扱いで良い*
*E = edge*

もちろん、面接時この辺りははっきりと覚えているわけではなく、危うくdfsでやろうと思ったところ、面接官からヒントをいただき、最短距離なのでdfsの効率はどうでしょうと。すると、「あぁ確かに」と、策をbfsに転換。

### コーディング

bfsの考え方について面接官に説明し、どのタイミングでリターンするかもはっきりしているので、割とイメージができているのではないかと、という状態でコーディングを始めました。この時点での問題とノートは大体以下となります。

```
有向図のノードxからノードxへ戻る最短パスを求めてください

- ノードから隣接するノードへ一方通行でトラバース
- リターン値はノードかエッジの配列（エッジの表現が思いついていないのでノードだけを考える）
- ノードxへ戻れる場合と戻れない場合は存在
  - 存在する場合は、ノードxからノードxまでのノードをパス配列として記録しリターン
  - 存在しない場合は、空の配列をリターン
- 結果リターンのタイミング
  - 存在する場合は、ノードxと2回目と会った時に
  - 存在しない場合は、全てのノードが訪問済み、whileループから脱出した時に
```

ここからも話しながら書くのが良いらしいですが、自分は話しながら書くのが苦手で、考えがついてから話して書くので、どうしても「考える時間の沈黙」が生まれてしまいます。この沈黙はあまり良くないですが、強引に話すと逆に思考が停止してしまうこともあるので、今回は何回か沈黙がありました。

ただ、考え方は面接官が理解できているので、こういう沈黙に落ちいても、向こうから何かヒントがいただくケースがあります（人によるかもしれませんが）。自分も今回肝心なヒントを2回いただいきました。色々と詰んでいたりしていましたが、なんとか回答まで辿り着きました。

```js
class Node {
  constructor(val = 0, neighbors = []) {
    this.val = val
    this.neighbors = neighbors
  }
}

function bfs(root) {
  let path = [root] // このパスで最短ルートを記録
  let queue = [[root, path]] // キューにはノード＋今までのパスを入れる
  let visited = new Set([root]) // ハッシュセットで訪問済みのノードを追加
  while (queue.length > 0) { // キューにノードがある限り処理を続ける
    const [node, path] = queue.shift() // キューの先頭からノードを取り出し、現時点までのパスも取得
    for (const neighbor of node.neighbors) { // ノードの隣接ノードをループ
      if (visited.has(neighbor)) {
        if (neighbor === root) { //隣接ノードが訪問済み、かつ最初のノードxと同じであれば、現在のパスが答え
          return path
        }
      } else {
        queue.push([neighbor, [...path, neighbor]]) // 訪問していないノードと今までのパスをキューにプッシュ
        visited.add(neighbor) // 同時に訪問済みとマーク
      }
    }
  }
  return [] // すべて訪問済みとなるとループが終わる、つまりxに戻ることができない
}
```

これを見てテンプレートとの違いといえば、depthへの関心がないため、forループが一つ少なくなりました。また、`queue`は本来ノードだけですが、パスの管理で悩んでいた時に、面接官からのヒントをいただいて、今までのパスも含めてキューに入れればどうなの、と。すると、なるほど、これでパスの管理が非常に楽になり、どこでプッシュしてまたどこでポップするのを考えずに済みます。

もう一つ肝心なヒントというのは、パスをリターンする場所です。一時的にどこでリターンしたら良いかわからなくなっていました。「ここで詰でたの？」と後から見ても不思議に思いますが、面接時はかなり緊張とプレッシャのある環境になるので、こういう状況も想定した方が良いと思います。

### 複雑度分析

複雑度分析は時間と空間両方必要です。通常はコーディングを始める前に、問題分析の段階でするものですが、今回の面接で全く忘れてしまい、コーディングが終わってから面接官から聞きました。

bfsについて正直あまり詳しくなく、ここはもう感覚で行くしかない感じです。

空間複雑度は割と分かりやすく、パス配列、キュー、ハッシュセットがあるので、最大O(3*n) = O(n)となるでしょう。ここのnはノードの数となります。

しかし時間複雑度はあまり直感的ではありません。ループが2階層あると見るとO(n**2)かなとかも見えますが、実際はそこまではないはず。というのは、訪問済みのノードはスキップされるので、全てのノードは一回しか訪問されません。スライディングウィンドウ（sliding window）のテクニックからの発想ですが、一回しか訪問されないため、例え2階層のループがあったとしても、時間複雑度はO(n)ですよと。それでO(n)で答えました。

面接官からは可否のコメントはなかったのですが、終わった後調べてみると、やはり考えが甘かったのです。

ここで見落としているのは、エッジとノード（グラフではvertex頂点とも呼ぶらしい）両方が存在するところです。

- エッジ数がノード数より多いまたは同じな場合
  - `∣N∣+∣E∣ ≤ ∣E∣+∣E∣ = 2*∣E∣` つまり結果的にO(E)、E = エッジ数となります
- エッジ数がノード数より少ない場合
  - `∣N∣+∣E∣ ≤ ∣N∣+∣N∣ = 2*∣N∣` つまり結果的にはO(N)、N = ノード数となります

二つのケースをカバーするには、複雑度が`O(E+N)`と記載されますが、事実上、`O(Max(E,N))`という意味になります。なので、O(n)という答えは半分しか当たっていません（[こちら](https://www.khanacademy.org/computing/computer-science/algorithms/breadth-first-search/a/analysis-of-breadth-first-search)にも参考）。

### 最後に

今回の問題というのは、少しグラフ経験があると非常に簡単な問題になるのではないかと思います。ただ、グラフ問題はそもそも難しい部類に入るので、それを日常的に解いている人はそもそも少ないとも思います。面接の時間に限りがあるので、このような難易度が妥当かもしれません。

自分の準備時間があまりなく、グラフ系問題は全く触る余裕がありませんでした。もし一回でもやってみたら、もっとすらすらと書けると思いました。しかし、やったことがなくても、諦めたら試合終了ですね。コーディング問題は必ずしもleetcodeとかからそのまんま取ってくるわけがないので、冷静に分析から入って、少しずつ近づいて行くのが必須だと。

今回のコーティング面接では、面接官のお助けがないと無理でした。ただ、自力で問題を解決する能力だけではなく、コミュニケーションと考え方を文章化・ノートに示すことが大事だと感じました。そうすると、自分が何をやりたいのか、面接官に伝わるので、適切なヒントももらえる可能性があります。開発はチームプレーなので、そこは意識すると、自力でクリアできない問題もできるようになるかもしれません。

なお、コーディング面接は本当に会社によって難易度がだいぶ変わります。実は前に別の会社さんからfizzbuzzの問題を受けました。しかし、簡単な問題であったとしても、面接環境の中で間違いをすることを想定した方が良いでしょう（自分はfizzbuzzで間違いした経験を持つ激レアエンジニアとして自慢しています）。それを克服するために、模擬面接で練習して、緊張を和らげるのが効果的らしいです。

ではでは、今回はこれで。
