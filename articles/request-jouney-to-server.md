---
title: "リクエストがxからxまでの旅"
emoji: "🚅"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["architecture", "infra", "systemdesign"]
published: false
---

# WHY

リクエストの視点からウェブアプリケーションのシステムアーキテクチャーを理解するのが目的。

そのシステムの中にどのようなコンポーネントがあるか、どのような働きをするか、どういった場面に必要になるか、をまとめる学習ノートでもある。


# マルチレベルのシステム

## 鳥瞰図

Fenix architectureの著者が、`Transparent Multilevel Diversion System`との概念を提唱しています。これは`Multilevel-cache`にちなんだ名前ですが、システム全体で見ればもちろんキャッシュの話だけではありません。また、`Transparent`はコンポーネントの間の通信でその後ろにあるマルチレベルの構造に意識しないから「透明」と説明されています。

この本では、フェニックス（不死鳥）のような何度でも蘇る堅牢なシステムを構築するために、考慮すべき内容を網羅しています。今時かなり普及されているクラウドサービスも含めて、よく見られるアーキテクチャ構成で考えるときに、リクエストがクライエント（この記事では主にブラウザーを指す）からサーバーまでは通常6つほどのレイヤーを通すことが必要です。すなわち、Client Cache -> DNS -> OSI Model -> CDN Server -> Load Balancer -> Server Cacheを経て、ようやくサーバーの方に届きます。


この記事では、これらのレイヤーのWHAT, WHY & HOWを述べていきたいと思います。


## Client Cache

### WHAT

ここのクライエントは、アプリケーションレイヤー（Next.jsで作られたアプリ、tantack routerのキャッシュ機能など）ではなく、ブラウザーを指しています。ブラウザーとサーバーの間ではHTTPベースの通信となり、[HTTP Caching](https://httpwg.org/specs/rfc9111.html)としてスペックが定義されています。以降は誤解を避けるために、HTTPキャッシュというふうに説明します（ブラウザーには他にも、サービスワーカーによるキャッシング、in-memoryのキャッシングとかがあります）。

> An HTTP cache is a local store of response messages and the subsystem that controls storage, retrieval, and deletion of messages in it.

スペックの説明の通り、1) レスポンスがブラウザーに保存される（local store）、2) その保存されたデータを制御するサブシステム、として理解して良いでしょう。


### WHY

なぜHTTPキャッシュが必要なのかというと、もちろんキャッシング共通のパフォーマンス向上もありますが、これはHTTPというプロトコルの無状態（stateless）とも関係しています。無状態というのは、一つ一つのHTTPリクエストが独立しており、前に送ったリクエストや後に送ったものと関係なく、それらのステートも保存しないことを指しています。そのために、cookieの運用が誕生されていますし、都度同じリクエストとレスポンスを繰り返さないためには、キャッシングもプロトコルの設計レベルから導入されています。

### HOW

HTTPキャッシュには視点次第でいくつかの分類軸がありますが、サーバーへの通信が発生するかどうかの観点から強制キャッシュと交渉キャッシュの2つのタイプがあります。

- 前者ではブラウザーのキャッシュを使い、サーバーへのリクエストがない -> `Expiration`をベースに
- 後者ではサーバーへリクエストを送り、キャッシュが使えるかどうかを問い合わせする -> `Validation`と`Condition`をベースに

| name | 強制 | 交渉 |
| --------------- | --------------- | --------------- |
| 判定ベース | Expiration(有効期間) | Validation(検証)とCondition(条件) |
| 関連ヘッダー | `Cache-Control`, `Expires` | `Etag`&`If-None-Match`, `Last-Modified`&`If-Modified-Since` |
| サーバーへリクエスト | 発生しない | 発生する |

強制キャッシュの場合だと、`Cache-Control`や`Expires`とかのヘッダーを利用することで制御できます。

- `Expires` ではHTTP-dateタイムスタンプ（例：` Wed, 28 Aug 2024 09:52:35 GMT`）の値が入る。名前通り有効期限が切れるまでHTTPキャッシュを使うことになり、サーバーへのリクエストが発生しない（できない）。ただ、HTTP1.0からのヘッダーで、いくつかの問題点がある
  - クライエントの時間に影響されてしまう問題 → 仮にクライエント側で時間を変更したとすると、キャッシュが最初に意図した時間より短いまたは長い寿命を持つことになる
  - キャッシュしない、場面には対応できない問題 → キャッシュしたいリソースとそうしたくないリソースの選別ができなくなる
  - パブリックとプライベートの選別ができない → 他の代理中間サーバー（例えばCDN）にキャッシュしたくないものの選別ができなくなる
- `Cache-Control`の方は現在普及されているもので、`Expires`の代替案としてHTTP1.1から導入されている。上記の問題点はもちろん解決されているし、より豊富なオプションで細かい制御が可能になっている。
  - `max-age`, `s-maxage` いずれも秒単位で有効時間指定を指定する、後者は`shared cache`の有効時間を指すため、`private`のついたリソースには無効。
  - `public`, `private` 今のブラウザーだけにキャッシュしてよいものと、代理中間サーバーにもキャッシュして良いものをこれで切り分ける。通常はユーザーごとのログイン情報など。指定がない場合デフォルトでは`public`となる。
  - `no-cache`, `no-store` キャッシュを無効化する関連オプション。ただ、結構紛らわしいのは、`no-cache`の方は名前通りキャッシュしないわけではなく、キャッシュはするが使う前に再度サーバー側と検証しなければならない。逆に、`no-store`の方はキャッシュを保存しないので、キャッシュをしないのが目的であれば、こちらの方が正解になる。
  - `no-transform` これも代理サーバーとかと関係があって、CDNで画像またはテキストのコンテンツを圧縮してスループットを向上させるなどのことを禁止する。
  - `min-fresh`, `only-if-cached` これらはクライエント側のリクエストに使われるヘッダー。min-freshは秒単位でサーバーから`max-age`が指定された秒数より大きいキャッシュリソースがほしい、を表している。`only-if-cached`の方は言葉通り、キャッシュ済みのリソースをください、とのこと。キャッシュがなければ直接504になる。
  - `must-revalidate`, `proxy-revalidate` `must-revalidate`は`max-age`が過ぎたあと必ず再度サーバーからリソースを取得しなければならない、つまりこの時は`no-cache`と同じ挙動になる。`proxy-revalidate`はCDNを含めた中間の代理サーバーのキャッシュ制御に対しての定義となり、使い方は`must-revalidate`と同じになる。

強制キャッシュは基本TTLに依存するものになりますが、TTL内でリソースが必ず変わらない保証は実は難しい場面がしばしばあります。その時に変化を検知して必要に応じてTTLが切らなくても再度リソースをサーバーから取得することができれば、この問題はだいぶ解決できるのではないかと。その考え方では、交渉キャッシュの問題意識になります。つまり、リソースの有効性についてクライエントとサーバーの間に会話を通して、キャッシュの行為を定めることになります。交渉キャッシュに使われるヘッダーはいくつかあります。

- `Last-Modified`, `If-Modified-Since` このペアについて、前者がサーバーからレスポンスのヘッダーになり、いわばリクエストされたリソースが最後に変更された時間。このヘッダーがついている場合、クライエントが再度同じリソースをリクエストする場合は、`If-Modified-Since`に前回受け取った`Last-Modified`を値を入れて、サーバー側に変更があるかどうかを問い合わせする。仮にサーバー側で変更なしの判断にすれば、`304/Not Modified`が返ってくる。逆に変更がありの場合、`200`で新しいリソースと、新しい`Last-Modified`のヘッダーが返ってくる。
- `Etag`, `If-None-Match` `Etag`はサーバー側のヘッダーになり、サーバー側で決められた方法で該当リソースに対して計算されたハッシュ値になっている。`If-None-Match`のほうはクライエント側で使うヘッダーで、前回受け取った`Etag`の値が入っている。そのため、リソースの内容に変更があると、このハッシュ値が合わなくなり、新しいリソースが返ってくる。逆に変わっていなければ、`304`が返ってくる。`Last-Modified`の運用方法と比べて、メリットとしてはリソースコンテンツに対する一致性が強く保証される（例えばコンテンツが変わっていないが`Last-Modified`が変わった場合、有効にキャッシュが使えないが、`Etag`なら変化なしで検知できる。ただしサーバーによって変更時間もハッシュ値計算項目にいれるため必ずこのケースになるわけでもない）。デメリットとして、やはり都度ハッシュ計算しなければならないところにあって、パフォーマンス面の懸念がある。
- `Etag`と`Last-Modified`が一緒に使う場合、優先的に`Etag`の検証がされ、一致した場合は`Last-Modified`の比較を行う。ハッシュ計算で変更時間を入れないケースもあるため、このようなステップになっている。

最後に、強制キャッシュと交渉キャッシュは共存するものであって、どれかにする必要がありません。強制キャッシュの`max-age`が切れた時、もしくは`no-cache/must-revalidate`の場合は、交渉キャッシュのヘッダーも利用可能です。

クライエントキャッシュの話はこれくらいでよしとして、もう一つの問題はキャッシュ内容のバリエーションになります。HTTPの設計上、一つのURLでリソースを特定するのですが、それを複数の形式で表現することが許されていて、具体的な表現形式が`Vary`とのヘッダーで制御しています。いわば[コンテンツ交渉](https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation) のことです。



## DNS

### WHAT
s
### WHY

### HOW


## OSI Model

## CDN

## LB(Server)

## Server Cache

# 終わりに
