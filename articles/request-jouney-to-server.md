---
title: "リクエストがxからxまでの旅"
emoji: "🚅"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["architecture", "infra", "systemdesign"]
published: false
---

# WHY

リクエストの視点からウェブアプリケーションのシステムアーキテクチャーを理解するのが目的。

そのシステムの中にどのようなコンポーネントがあるか、どのような働きをするか、どういった場面に必要になるか、をまとめる学習ノートでもある。


# マルチレベルのシステム

## 鳥瞰図

Fenix architectureの著者が、`Transparent Multilevel Diversion System`との概念を提唱しています。これは`Multilevel-cache`にちなんだ名前ですが、システム全体で見ればもちろんキャッシュの話だけではありません。また、`Transparent`はコンポーネントの間の通信でその後ろにあるマルチレベルの構造に意識しないから「透明」と説明されています。

この本では、フェニックス（不死鳥）のような何度でも蘇る堅牢なシステムを構築するために、考慮すべき内容を網羅しています。今時かなり普及されているクラウドサービスも含めて、よく見られるアーキテクチャ構成で考えるときに、リクエストがクライエント（この記事では主にブラウザーを指す）からサーバーまでは通常6つほどのレイヤーを通すことが必要です。すなわち、Client Cache -> DNS -> OSI Model -> CDN Server -> Load Balancer -> Server Cacheを経て、ようやくサーバーの方に届きます。


この記事では、これらのレイヤーのWHAT, WHY & HOWを述べていきたいと思います。


## Client Cache

### WHAT

ここのクライエントは、アプリケーションレイヤー（Next.jsで作られたアプリ、tantack routerのキャッシュ機能など）ではなく、ブラウザーを指しています。ブラウザーとサーバーの間ではHTTPベースの通信となり、[HTTP Caching](https://httpwg.org/specs/rfc9111.html)としてスペックが定義されています。以降は誤解を避けるために、HTTPキャッシュというふうに説明します（ブラウザーには他にも、サービスワーカーによるキャッシング、in-memoryのキャッシングとかがあります）。

> An HTTP cache is a local store of response messages and the subsystem that controls storage, retrieval, and deletion of messages in it.

スペックの説明の通り、1) レスポンスがブラウザーに保存される（local store）、2) その保存されたデータを制御するサブシステム、として理解して良いでしょう。


### WHY

なぜHTTPキャッシュが必要なのかというと、もちろんキャッシング共通のパフォーマンス向上もありますが、これはHTTPというプロトコルの無状態（stateless）とも関係しています。無状態というのは、一つ一つのHTTPリクエストが独立しており、前に送ったリクエストや後に送ったものと関係なく、それらのステートも保存しないことを指しています。そのために、cookieの運用が誕生されていますし、都度同じリクエストとレスポンスを繰り返さないためには、キャッシングもプロトコルの設計レベルから導入されています。

### HOW

HTTPキャッシュには視点次第でいくつかの分類軸がありますが、サーバーへの通信が発生するかどうかの観点から強制キャッシュと問い合わせキャッシュの2つのタイプがあります。

- 前者ではブラウザーのキャッシュを使い、サーバーへのリクエストがない -> `Expiration`をベースに
- 後者ではサーバーへリクエストを送り、キャッシュが使えるかどうかを問い合わせする -> `Validation`と`Condition`をベースに

| name | 強制 | 問い合わせ |
| --------------- | --------------- | --------------- |
| 判定ベース | Expiration(有効期間) | Validation(検証)とCondition(条件) |
| 関連ヘッダー | `Cache-Control`, `Expires` | `Etag`&`If-None-Match`, `Last-Modified`&`If-Modified-Since` |
| サーバーへリクエスト | 発生しない | 発生する |

強制キャッシュの場合だと、`Cache-Control`や`Expires`とかのヘッダーを利用することで制御できます。

- `Expires` ではHTTP-dateタイムスタンプ（例：` Wed, 28 Aug 2024 09:52:35 GMT`）の値が入る。名前通り有効期限が切れるまでHTTPキャッシュを使うことになり、サーバーへのリクエストが発生しない（できない）。ただ、HTTP1.0からのヘッダーで、いくつかの問題点がある
  - クライエントの時間に影響されてしまう問題 → 仮にクライエント側で時間を変更したとすると、キャッシュが最初に意図した時間より短いまたは長い寿命を持つことになる
  - キャッシュしない、場面には対応できない問題 → キャッシュしたいリソースとそうしたくないリソースの選別ができなくなる
  - パブリックとプライベートの選別ができない → 他の代理中間サーバー（例えばCDN）にキャッシュしたくないものの選別ができなくなる
- `Cache-Control`の方は現在普及されているもので、`Expires`の代替案としてHTTP1.1から導入されている。上記の問題点はもちろん解決されているし、より豊富なオプションで細かい制御が可能になっている。
  - `max-age`, `s-maxage` いずれも秒単位で有効時間指定を指定する、後者は`shared cache`の有効時間を指すため、`private`のついたリソースには無効。
  - `public`, `private` 今のブラウザーだけにキャッシュしてよいものと、代理中間サーバーにもキャッシュして良いものをこれで切り分ける。通常はユーザーごとのログイン情報など。指定がない場合デフォルトでは`public`となる。
  - `no-cache`, `no-store` キャッシュを無効化する関連オプション。ただ、結構紛らわしいのは、`no-cache`の方は名前通りキャッシュしないわけではなく、キャッシュはするが使う前に再度サーバー側と検証しなければならない。逆に、`no-store`の方はキャッシュを保存しないので、キャッシュをしないのが目的であれば、こちらの方が正解になる。
  - `no-transform` これも代理サーバーとかと関係があって、CDNで画像またはテキストのコンテンツを圧縮してスループットを向上させるなどのことを禁止する。
  - `min-fresh`, `only-if-cached` これらはクライエント側のリクエストに使われるヘッダー。min-freshは秒単位でサーバーから`max-age`が指定された秒数より大きいキャッシュリソースがほしい、を表している。`only-if-cached`の方は言葉通り、キャッシュ済みのリソースをください、とのこと。キャッシュがなければ直接504になる。
  - `must-revalidate`, `proxy-revalidate` `must-revalidate`は`max-age`が過ぎたあと必ず再度サーバーからリソースを取得しなければならない、つまりこの時は`no-cache`と同じ挙動になる。`proxy-revalidate`はCDNを含めた中間の代理サーバーのキャッシュ制御に対しての定義となり、使い方は`must-revalidate`と同じになる。

強制キャッシュは基本TTLに依存するものになりますが、TTL内でリソースが必ず変わらない保証は実は難しい場面がしばしばあります。その時に変化を検知して必要に応じてTTLが切らなくても再度リソースをサーバーから取得することができれば、この問題はだいぶ解決できるのではないかと。その考え方では、問い合わせキャッシュの問題意識になります。つまり、リソースの有効性についてクライエントとサーバーの間に会話を通して、キャッシュの行為を定めることになります。問い合わせキャッシュに使われるヘッダーはいくつかあります。

- `Last-Modified`, `If-Modified-Since` このペアについて、前者がサーバーからレスポンスのヘッダーになり、いわばリクエストされたリソースが最後に変更された時間。このヘッダーがついている場合、クライエントが再度同じリソースをリクエストする場合は、`If-Modified-Since`に前回受け取った`Last-Modified`を値を入れて、サーバー側に変更があるかどうかを問い合わせする。仮にサーバー側で変更なしの判断にすれば、`304/Not Modified`が返ってくる。逆に変更がありの場合、`200`で新しいリソースと、新しい`Last-Modified`のヘッダーが返ってくる。
- `Etag`, `If-None-Match` `Etag`はサーバー側のヘッダーになり、サーバー側で決められた方法で該当リソースに対して計算されたハッシュ値になっている。`If-None-Match`のほうはクライエント側で使うヘッダーで、前回受け取った`Etag`の値が入っている。そのため、リソースの内容に変更があると、このハッシュ値が合わなくなり、新しいリソースが返ってくる。逆に変わっていなければ、`304`が返ってくる。`Last-Modified`の運用方法と比べて、メリットとしてはリソースコンテンツに対する一致性が強く保証される（例えばコンテンツが変わっていないが`Last-Modified`が変わった場合、有効にキャッシュが使えないが、`Etag`なら変化なしで検知できる。ただしサーバーによって変更時間もハッシュ値計算項目にいれるため必ずこのケースになるわけでもない）。デメリットとして、やはり都度ハッシュ計算しなければならないところにあって、パフォーマンス面の懸念がある。
- `Etag`と`Last-Modified`が一緒に使う場合、優先的に`Etag`の検証がされ、一致した場合は`Last-Modified`の比較を行う。ハッシュ計算で変更時間を入れないケースもあるため、このようなステップになっている。

最後に、強制キャッシュと問い合わせキャッシュは共存するものであって、どれかにする必要がありません。強制キャッシュの`max-age`が切れた時、もしくは`no-cache/must-revalidate`の場合は、問い合わせキャッシュのヘッダーも利用可能です。

クライエントキャッシュの話はこれくらいでよしとして、もう一つの問題はキャッシュ内容のバリエーションになります。HTTPの設計上、一つのURLでリソースを特定するのですが、それを複数の形式で表現することが許されています。具体的な表現形式が`Vary`との`Accept*`系のヘッダーで制御しています。いわば[コンテンツ交渉](https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation) のことです。

![](https://storage.googleapis.com/zenn-user-upload/ad4bb76391cc-20241221.png)
[出典MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation#principles_of_content_negotiation)

例えば、同じ`domain.com/home.html`のリソースが存在するとして、多言語対応のために`Accept-Language`のヘッダーに基づいて対応バージョンのリソースをレスポンスとして返します。このケースだと`Vary: Accept-Language, Accept-Language: ja-JP`を追加すると、同じリソースの日本語形式の物をくださいとのリクエストになります。他によくある、`Accept-Encoding`, `Accept`(MIMEタイプ)などが挙げられますが、考え方は同じです。キャッシュを作る時にはコンテンツ交渉にも影響されるので、同じURLだからキャッシュされいるとは限らないことになります。

## DNS

### WHAT

初心者の頃はDNSの解説を色々と探っていて、要するに「ドメイン名とIPアドレスを記録する電話帳」的な物、しか理解がありませんでした。もちろん、機能だけ考えると、ドメイン名とIPアドレスの対応付（正引き逆引きを含め）を管理するシステムとして正しいと思います。今のインターネットの基盤にとって不可欠な部分とはなりますが、その巧みなマルチレイヤーの設計によってインターネット全体のボトルネックになりませんでした。

### WHY

存在の意義として、IPv4またはIPv6のアドレスを覚えるよりは、`zenn.dev`とかが一瞬で伝わるし覚えられやすいのです。この意味で言えば人間とコンピュータにとってそれぞれ適切な表現形式を保存して紐付きすることをやっています。また、ドメイン名を覚えれば良いとのことなので、実際にIPアドレスが変わっても関心を持つ必要がありません。

### HOW

ドメイン名をDNSサーバーへリクストして、正しいIPアドレスを教えてもらうのが根本的な仕組みですが、 DNSサーバーを言っても実はいくつか種類に分けられることができます。一つのDNSLook upクエリーで絡んでいる内容で言えば、以下となります（[参考](https://www.cloudflare.com/learning/dns/dns-server-types/) ）。ここは電話帳の例より、図書館の例で考えた方がわかりやすいかもしれません。

- DNS recursor ここは図書館で受付の役割を持っています。顧客（ブラウザーなどのクライエント）からの探したい本の注文（ドメイン対応するIPアドレス）を受けて、必要な情報を他の知っているサーバーへ問い合わせします。
- Root nameserver ルートサーバーは図書館のインデックスシステムとも考えられます。どの階層（TLDサーバー）にどの棚（トップレベルドメイン情報）があるかは知っていますが、本がどの棚（Authoritative nameserver）にあるかはわかりません。
- TLD(Top Level Domain) nameserver 特定の階層（`.com`, `.org`, `.dev`, `.jp`などのトップレベルのドメイン）の情報を持っていて、どの棚（Authoritative nameserver）に本があるかの情報を知っています。
- Authoritative nameserver ここはそれぞれの本棚に相当していて、各自の棚にある本の内容（IPアドレス）の情報を把握しています。つまり最終的にDNSネットワーク上で具体的にIPアドレス情報を記録しているのはこちらになります。


![](https://storage.googleapis.com/zenn-user-upload/fd5038ca6960-20241221.png)
[出典cloudflare](https://www.cloudflare.com/learning/dns/what-is-dns/)

DNSクエリー自体は、これらのレイヤーを全て通ることはもちろん滅多にありません。ここの`zenn.dev`へアクセス例として（仮に初めてのリクエストでキャッシュは各レイヤーにない状態）、流れとしては

- ローカル（ブラウザー、なければOS）のDNSキャッシュをまず確認し、TTL期間内のドメイン名の持っているIPアドレスがあるかを確認する。ここは
図書館の例えで言えば、自宅の本棚に相当します。もちろん、IPアドレスが仮に変わっても、TTLが切れるまで＝再度リクエストするまでは「住所が見つからない」サービスダウンの時期が発生します。他のレイヤーも同じくTTL依存します。
- ローカル（自宅の本棚）にはない場合、次にrecursive resolverのサーバー（図書館の受付）にリクエストします。ここは通常ネットワークサービスを提供するプロバイダーになります。キャッシュになければ次にRootサーバー（図書館のインデックスシステム）にリクエストを飛ばします。
- ルートサーバーでは、トップレベルのドメインを管理するTLDサーバー（図書館のN階）のアドレス帳を持っているので、その中から`.dev`がどのTLDサーバーにあるかを返します。
- recursive resolverはさらにこのTLDサーバーにリクエストして、`zenn.dev`のIPアドレスを教えてください、と要求します。ここで直接IPアドレスを返すわけではなく、`zenn.dev`のIPアドレスが知っているAuthoritativeサーバー（N階にあるX本棚）のアドレスを返します。
- recursive resolverは今度こそ、Authoritativeサーバーのアドレスにリクエストして、`zenn.dev`のIPアドレスを教えてください、と要求します。ようやく、正しいIPアドレス（N階にあるX本棚にある本）が取れたら、ブラウザーなどのクライエントへ返します。もちろん、今度のリクエストがスムーズにできるように、IPアドレスをキャッシュします。
- クライエント側でそのIPアドレスを持って、`zenn.dev`へアクセスして、リソースを取得して画面がレンダリングされ始めます。


このマルチレイヤーの設計には、いくつかのメリットを持っています。

- アクセス集中することを避けて負荷を分散させている
- 各レイヤーの分割によって役割分担をし、ドメインの追加やトップレベルドメインの管理が柔軟になる
- 各レイヤーのキャッシュを通して、クリエリーの効率性が向上する
- 各レイヤーDNSサーバー自体も、分散型システムになっているため、同じデータを持つサーバーが複数に存在し、耐障害性も高い

もちろん、デメリットも存在します。
- 上記のような各レイヤーにキャッシュがない極端なケースになると、TTL無効になったあとの初回リクエストの時間がかかりる
- Man In the Middle攻撃セキュリティ上の懸念（[参考](https://www.cloudflare.com/learning/dns/dns-security/) ）
- メンテナンスの複雑さ、これは自社で設ける場合はありそうだが、現状クラウドサービスに任せることが多いでしょう

## OSI Model

## CDN

## LB(Server)

## Server Cache

# 終わりに
