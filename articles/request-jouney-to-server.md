---
title: "リクエストがxからxまでの旅"
emoji: "🚅"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["architecture", "infra", "systemdesign"]
published: false
---

# WHY

リクエストの視点からウェブアプリケーションのシステムアーキテクチャーを理解するのが目的。

そのシステムの中にどのようなコンポーネントがあるか、どのような働きをするか、どういった場面に必要になるか、をまとめる学習ノートでもある。


# マルチレベルのシステム

## 鳥瞰図

Fenix architectureの著者が、`Transparent Multilevel Diversion System`との概念を提唱しています。これは`Multilevel-cache`にちなんだ名前ですが、システム全体で見ればもちろんキャッシュの話だけではありません。また、`Transparent`はコンポーネントの間の通信でその後ろにあるマルチレベルの構造に意識しないから「透明」と説明されています。

この本では、フェニックス（不死鳥）のような何度でも蘇る堅牢なシステムを構築するために、考慮すべき内容を網羅しています。今時かなり普及されているクラウドサービスも含めて、よく見られるアーキテクチャ構成で考えるときに、リクエストがクライエント（この記事では主にブラウザーを指す）からサーバーまでは通常6つほどのレイヤーを通すことが必要です。すなわち、Client Cache -> DNS -> OSI Model -> CDN Server -> Load Balancer -> Server Cacheを経て、ようやくサーバーの方に届きます。


この記事では、これらのレイヤーのWHAT, WHY & HOWを述べていきたいと思います。


## Client Cache

### WHAT

ここのクライエントは、アプリケーションレイヤー（Next.jsで作られたアプリ、tantack routerのキャッシュ機能など）ではなく、ブラウザーを指しています。ブラウザーとサーバーの間ではHTTPベースの通信となり、[HTTP Caching](https://httpwg.org/specs/rfc9111.html)としてスペックが定義されています。以降は誤解を避けるために、HTTPキャッシュというふうに説明します（ブラウザーには他にも、サービスワーカーによるキャッシング、in-memoryのキャッシングとかがあります）。

> An HTTP cache is a local store of response messages and the subsystem that controls storage, retrieval, and deletion of messages in it.

スペックの説明の通り、1) レスポンスがブラウザーに保存される（local store）、2) その保存されたデータを制御するサブシステム、として理解して良いでしょう。


### WHY

なぜHTTPキャッシュが必要なのかというと、もちろんキャッシング共通のパフォーマンス向上もありますが、これはHTTPというプロトコルの無状態（stateless）とも関係しています。無状態というのは、一つ一つのHTTPリクエストが独立しており、前に送ったリクエストや後に送ったものと関係なく、それらのステートも保存しないことを指しています。そのために、cookieの運用が誕生されていますし、都度同じリクエストとレスポンスを繰り返さないためには、キャッシングもプロトコルの設計レベルから導入されています。

### HOW

HTTPキャッシュには視点次第でいくつかの分類軸がありますが、サーバーへの通信が発生するかどうかの観点から強制キャッシュと交渉キャッシュの2つのタイプがあります。

- 前者ではブラウザーのキャッシュを使い、サーバーへのリクエストがない -> `Expiration`をベースに
- 後者ではサーバーへリクエストを送り、キャッシュが使えるかどうかを問い合わせする -> `Validation`と`Condition`をベースに

| name | 強制 | 交渉 |
| --------------- | --------------- | --------------- |
| 判定ベース | Expiration(有効期間) | Validation(検証)とCondition(条件) |
| 関連ヘッダー | `Cache-Control`, `Expires` | `Etag`&`If-None-Match`, `Last-Modified`&`If-Modified-Since` |
| サーバーへリクエスト | 発生しない | 発生する |

強制キャッシュの場合だと、`Cache-Control`や`Expires`とかのヘッダーを利用することで制御できます。

- `Expires` ではHTTP-dateタイムスタンプ（例：` Wed, 28 Aug 2024 09:52:35 GMT`）の値が入る。名前通り有効期限が切れるまでHTTPキャッシュを使うことになり、サーバーへのリクエストが発生しない（できない）。ただ、HTTP1.0からのヘッダーで、いくつかの問題点がある
  - クライエントの時間に影響されてしまう問題 → 仮にクライエント側で時間を変更したとすると、キャッシュが最初に意図した時間より短いまたは長い寿命を持つことになる
  - キャッシュしない、場面には対応できない問題 → キャッシュしたいリソースとそうしたくないリソースの選別ができなくなる
  - パブリックとプライベートの選別ができない → 他の代理中間サーバー（例えばCDN）にキャッシュしたくないものの選別ができなくなる
- `Cache-Control`の方は現在普及されているもので、`Expires`の代替案としてHTTP1.1から導入されている。上記の問題点はもちろん解決されているし、より豊富なオプションで細かい制御が可能になっている。
  - `max-age`, `s-maxage` いずれも秒単位で有効時間指定を指定する、後者は`shared cache`の有効時間を指すため、`private`のついたリソースには無効。
  - `public`, `private` 今のブラウザーだけにキャッシュしてよいものと、代理中間サーバーにもキャッシュして良いものをこれで切り分ける。通常はユーザーごとのログイン情報など。指定がない場合デフォルトでは`public`となる。
  - `no-cache`, `no-store` キャッシュを無効化する関連オプション。ただ、結構紛らわしいのは、`no-cache`の方は名前通りキャッシュしないわけではなく、キャッシュはするが使う前に再度サーバー側と検証しなければならない。逆に、`no-store`の方はキャッシュを保存しないので、キャッシュをしないのが目的であれば、こちらの方が正解になる。
  - `no-transform` これも代理サーバーとかと関係があって、CDNで画像またはテキストのコンテンツを圧縮してスループットを向上させるなどのことを禁止する。
  - `min-fresh`, `only-if-cached`
  - `must-revalidate`, `proxy-revalidate`


## DNS

### WHAT

### WHY

### HOW


## OSI Model

## CDN

## LB(Server)

## Server Cache

# 終わりに
